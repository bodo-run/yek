
use anyhow::Result;
use predicates::prelude::*;
use std::{
    fs::{self, File},
    io::Write,
    path::Path,
    process::Command,
    thread,
    time::{Duration, SystemTime},
};
use tempfile::TempDir;

struct TestSetup {
    dir: TempDir,
    config: Option<String>,
    git: bool,
}

impl TestSetup {
    fn new() -> Self {
        TestSetup {
            dir: TempDir::new().unwrap(),
            config: None,
            git: false,
        }
    }

    fn with_config(mut self, config: &str) -> Self {
        self.config = Some(config.to_string());
        self
    }

    fn with_git(mut self) -> Self {
        self.git = true;
        self
    }

    fn create_file(&self, path: &str, contents: &str) -> String {
        let full_path = self.dir.path().join(path);
        fs::create_dir_all(full_path.parent().unwrap()).unwrap();
        fs::write(&full_path, contents).unwrap();
        full_path.to_str().unwrap().to_string()
    }

    fn create_binary_file(&self, path: &str, size: usize) -> String {
        let full_path = self.dir.path().join(path);
        let content = vec![0u8; size];
        fs::write(&full_path, content).unwrap();
        full_path.to_str().unwrap().to_string()
    }

    fn run(&self, args: &[&str]) -> (String, String) {
        let mut cmd = Command::new(env!("CARGO_BIN_EXE_yek"));
        cmd.arg("--no-stream");
        
        if let Some(config) = &self.config {
            let config_path = self.dir.path().join("yek.toml");
            fs::write(&config_path, config).unwrap();
            cmd.arg("--config").arg(config_path);
        }
        
        cmd.arg(self.dir.path());
        cmd.args(args);
        
        let output = cmd.output().unwrap();
        (
            String::from_utf8_lossy(&output.stdout).into_owned(),
            String::from_utf8_lossy(&output.stderr).into_owned(),
        )
    }

    fn git_init(&self) {
        Command::new("git")
            .arg("init")
            .current_dir(self.dir.path())
            .output()
            .unwrap();
    }

    fn git_commit(&self, message: &str) {
        Command::new("git")
            .args(["add", "."])
            .current_dir(self.dir.path())
            .output()
            .unwrap();
            
        Command::new("git")
            .args(["commit", "-m", message])
            .current_dir(self.dir.path())
            .env("GIT_AUTHOR_DATE", "2024-01-01T00:00:00")
            .env("GIT_COMMITTER_DATE", "2024-01-01T00:00:00")
            .output()
            .unwrap();
    }
}

#[test]
fn test_basic_processing() -> Result<()> {
    let setup = TestSetup::new()
        .create_file("src/main.rs", "fn main() {}")
        .create_file("image.png", "binary data")
        .create_binary_file("big.bin", 1024);

    let (output, _) = setup.run(&[]);
    
    // Should include text files
    assert!(output.contains("src/main.rs"));
    
    // Should exclude binary files
    assert!(!output.contains("image.png"));
    assert!(!output.contains("big.bin"));
    
    Ok(())
}

#[test]
fn test_ignore_patterns() -> Result<()> {
    let config = r#"
        ignore_patterns = ["temp/*", "*.log"]
    "#;
    
    let setup = TestSetup::new()
        .with_config(config)
        .create_file("temp/file.txt", "ignore")
        .create_file("app.log", "logs")
        .create_file("src/main.rs", "code");

    let (output, _) = setup.run(&[]);
    
    assert!(!output.contains("temp/file.txt"));
    assert!(!output.contains("app.log"));
    assert!(output.contains("src/main.rs"));
    
    Ok(())
}

#[test]
fn test_priority_ordering() -> Result<()> {
    let config = r#"
        [[priority_rules]]
        pattern = "src/*"
        score = 10
        
        [[priority_rules]]
        pattern = "tests/*"
        score = 5
    "#;
    
    let setup = TestSetup::new()
        .with_config(config)
        .create_file("src/a.rs", "a")
        .create_file("tests/b.rs", "b")
        .create_file("docs/c.md", "c");

    let (output, _) = setup.run(&[]);
    
    let positions = [
        output.find("src/a.rs"),
        output.find("tests/b.rs"), 
        output.find("docs/c.md"),
    ];
    
    assert!(positions[0] < positions[1]);
    assert!(positions[1] < positions[2]);
    
    Ok(())
}

#[test]
fn test_git_commit_ordering() -> Result<()> {
    let setup = TestSetup::new()
        .with_git()
        .create_file("file1.txt", "1")
        .create_file("file2.txt", "2");
        
    setup.git_init();
    
    // Initial commit
    setup.git_commit("Initial commit");
    
    // Modify file2 and commit
    setup.create_file("file2.txt", "updated");
    setup.git_commit("Update file2");
    
    let (output, _) = setup.run(&[]);
    
    let pos1 = output.find("file1.txt").unwrap();
    let pos2 = output.find("file2.txt").unwrap();
    assert!(pos2 < pos1, "Recently modified file2 should come first");
    
    Ok(())
}

#[test]
fn test_token_mode_truncation() -> Result<()> {
    let config = r#"
        token_mode = true
        tokenizer_model = "openai"
        max_size = "10"
    "#;
    
    let setup = TestSetup::new()
        .with_config(config)
        .create_file("long.txt", "This is a test sentence that should be truncated.");
    
    let (output, _) = setup.run(&[]);
    
    // Verify truncation happened
    assert!(output.len() < 50);
    assert!(output.contains("[TRUNCATED]") || output.ends_with("..."));
    
    Ok(())
}

#[test]
fn test_config_merging() -> Result<()> {
    let global_config = r#"
        ignore_patterns = ["global_ignore"]
        binary_extensions = ["xyz"]
    "#;
    
    let dir_config = r#"
        ignore_patterns = ["local_ignore"]
        priority_rules = [{ pattern = "src/*", score = 10 }]
    "#;
    
    let setup = TestSetup::new()
        .with_config(global_config)
        .create_file("yek.toml", dir_config)
        .create_file("global_ignore", "")
        .create_file("local_ignore", "")
        .create_file("src/main.rs", "")
        .create_file("file.xyz", "");
    
    let (output, _) = setup.run(&[]);
    
    assert!(!output.contains("global_ignore"));  // Both ignores should be excluded
    assert!(!output.contains("local_ignore"));
    assert!(output.contains("src/main.rs"));     // Priority file included
    assert!(!output.contains("file.xyz"));       // Custom binary extension excluded
    
    Ok(())
}

#[test]
fn test_error_handling() -> Result<()> {
    // Test invalid model
    let setup = TestSetup::new();
    let (_, stderr) = setup.run(&["--tokens=invalid"]);
    assert!(stderr.contains("Unsupported model family"));

    // Test invalid size format
    let (_, stderr) = setup.run(&["--max-size=10invalid"]);
    assert!(stderr.contains("Invalid byte format"));

    // Test invalid config file
    let setup = TestSetup::new().with_config("invalid toml");
    let (_, stderr) = setup.run(&[]);
    assert!(stderr.contains("Failed to parse config"));

    Ok(())
}

#[test]
fn test_output_modes() -> Result<()> {
    // Test byte mode
    let setup = TestSetup::new()
        .create_file("test.txt", "A".repeat(5000));
    
    let (output, _) = setup.run(&["--max-size=1KB"]);
    assert!(output.len() <= 1024);

    // Test token mode
    let config = r#"
        token_mode = true
        max_size = "5"
    "#;
    
    let setup = TestSetup::new()
        .with_config(config)
        .create_file("test.txt", "Hello world");
    
    let (output, _) = setup.run(&[]);
    assert!(output.len() < "Hello world".len());

    Ok(())
}