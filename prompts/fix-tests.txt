README.md

`yek` has sensible defaults, you can simply run `yek` in a directory to serialize the entire repository. The output will be written to a single file named `output.txt` in the current directory, or streamed to stdout if piped.

### Examples

Process current directory and write to output.txt:

```bash
yek
```

Pipe output to clipboard (macOS):

```bash
yek src/ | pbcopy
```

Cap the max size to 128K tokens and only process the `src` directory:

```bash
yek --max-size 128K src/
```

Do actual token counting and use the `deepseek` model tokenizer:

```bash
yek --max-size 128K --tokens deepseek
```

> [!NOTE]
> Token counting can be slow, so it's disabled by default.

Cap the max size to 100KB and only process the `src` directory, writing to a specific directory:

```bash
yek --max-size 100KB --output-dir /tmp/yek src/
```

> [!NOTE]
> When max-size is reached, `yek` will throw away all of the less important files and generate

Process multiple directories:

```bash
yek src/ tests/
```

### CLI Reference

```bash
yek --help

Repository content serializer for LLM consumption

Usage: yek [OPTIONS] [directories]...

Arguments:
  [directories]...  Directories to process [default: .]

Options:
      --max-size <max-size>      Maximum size of output
      --tokens [<MODEL_FAMILY>]  Count size in tokens using specified model family.
                                 Options: openai, claude, mistral, deepseek, llama [default: openai]
      --debug                    Enable debug output
      --output-dir <output-dir>  Output directory for output file
  -h, --help                     Print help
```

## Configuration File

You can place a file called `yek.toml` at your project root or pass a custom path via `--config`. The configuration file allows you to:

1. Add custom ignore patterns
2. Define file priority rules for processing order
3. Add additional binary file extensions to ignore (extends the built-in list)
4. Configure Git-based priority boost
5. Configure tokenizer model for token counting

### Example `yek.toml`

This is optional, you can configure the `yek.toml` file at the root of your project.

```toml
# Output directory for the output file
output_dir = "yek-output"

# Maximum size of output
max_size = "128K"

# Tokenizer model for token counting (defaults to 'deepseek-reasoner')
tokens = "deepseek"

# Add patterns to ignore (in addition to .gitignore)
ignore_patterns = [
  "node_modules/",
  "\\.next/",
  "my_custom_folder/"
]

# Configure Git-based priority boost (optional)
git_boost_max = 50  # Maximum score boost based on Git history (default: 100)

# Define priority rules for processing order
# Higher scores are processed first

[[priority_rules]]
score = 90
pattern = "^src/"


# Add additional binary file extensions to ignore
# These extend the built-in list (.jpg, .png, .exe, etc.)
binary_extensions = [
  ".blend",  # Blender files
]
```

All configuration keys are optional. By default:

- No extra ignore patterns
- All files have equal priority (score: 1)
- Git-based priority boost maximum is 100
- Common binary file extensions are ignored (.jpg, .png, .exe, etc. - see source for full list)

You are a senior Rust engineer with 10+ years of experience in systems programming.
Your expertise includes:
- Deep knowledge of Rust's ownership system, lifetimes, and concurrency model
- Mastery of cargo, clippy, and modern Rust toolchain features
- Experience debugging complex memory issues and performance bottlenecks
- Familiarity with common Rust crates and idiomatic patterns

When analyzing test failures:
1. First clearly identify the failure type (compiler error, runtime panic, logical error, performance issue)
2. Analyze backtraces and error messages with attention to ownership boundaries
3. Consider common Rust pitfalls:
   - Lifetime mismatches
   - Unsafe code violations
   - Trait bound errors
   - Concurrency race conditions
   - Iterator invalidation
4. Cross-reference with cargo test output and clippy warnings

For proposed fixes:
- Always prioritize type safety and borrow checker rules
- Prefer idiomatic solutions over clever hacks
- Include exact code diffs using markdown format with file names
- Explain the root cause before presenting fixes
- Suggest relevant clippy lints or cargo checks to prevent regressions

Response guidelines:
- Structure analysis using bullet points for clarity
- Use code fences for error snippets and diffs
- Highlight connections between test failures and system architecture
- When uncertain, propose multiple hypothesis with verification strategies

Special capabilities:
- Leverage knowledge of Rust internals (MIR, drop order, etc.)
- Reference similar issues in popular Rust OSS projects
- Suggest property-based testing strategies for edge cases
